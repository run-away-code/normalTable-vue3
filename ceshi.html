<html xmlns="http://www.w3.org/1999/xhtml">  
<head>  
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />  
</head>  
<body>  
    <div id="div">aaaaa</div>
</body>  
<script>
// 优先队列  先进按优先级出



// console.log(123123)
    //  async function async1() {
    //      console.log('async1 start');
    //      await async2(); 
    //      console.log('async1 end');
    //  }
    //  async function async2() {
    //      console.log('async2');
    //      return async1()
    //  }
    //  console.log('script start');
    //  setTimeout(function() {
    //      console.log('setTimeout');
    //  }, 0)
    //  async1();
    //  new Promise(function(resolve) {
    //     console.log('promise1');
    //     resolve();
    //     console.log(1);
    //     reject('error');
    //  }).then(function() {
    //      console.log('promise2');
    //  }).catch(e => console.log(e))
    //  console.log('script end');





const obj = {
    text: 'aaa'
}

const a = 'text'
const { [a]: aaa} = obj
console.log(aaa, 'ddd')
// const effect = () => {
//     document.getElementById('div').innerHTML = obj.text
// }
// effect()
// setTimeout(() => {
//     obj.text = 'bbb'
    
// }, 2000);

// Object.defineProperty(obj, 'text', {
//     get:function() {
//         console.log(obj.text)
//         return obj.text
//     },
//     set:function(it) {
//         effect()
//         // console.log(it, 'ttt')
//         // obj.text = it
//         console.log('set')
//     }
// })

// setTimeout(() => {
//     obj.a = [0, 1, 2]
//     console.log(obj.a, 'ddd')
//     obj.a.push('9')
//     console.log(obj, 'ddd')

// }, 1000);


// function getdate() {
//     return new Date()
// }
// function getdate() {
//     return new Date('2020/01/01')
// }



// function changeObj(o){
//     o.site = 'baidu'
//     o = new Object()
//     o.site = 'safari'
// }
// let webSite = new Object()
// webSite.site = 'googel'
// changeObj(webSite)
// console.log(webSite.site)





// 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

// 说明：每次只能向下或者向右移动一步。

// 示例 1：
// 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
// 输出：7
// 解释：因为路径 1→3→1→1→1 的总和最小。
















// 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
// 你应当 保留 两个分区中每个节点的初始相对位置。
// 输入：head = [1,4,3,2,5,2], x = 3
// 输出：[1,2,2,4,3,5]

// var partition = function(head, x) {
//     let node1 = new Node();
//     let node2 = new Node()
//     let currentNode = head;
//     while(currentNode.next !== null){
//         if(currentNode.value<3){
//             node1.next = currentNode;
//             node1 = currentNode;
//             currentNode = currentNode.next;
//         }else{
//             node2.next = currentNode;
//             node2 = currentNode;
//             currentNode = currentNode.next;
//         }
//     }
    
// }




    // let isMount = true
    // let workInprogressHook = null
    // const fiber = {
    //     memoizeState: null,
    //     stateNode: App
    // }
    // function schedule() {
    //     workInprogressHook = fiber.memoizeState
    //     const app = fiber.stateNode()
    //     isMount = false // 首次调用赋值为false
    //     return app
    // }
    // function useState(initState, fn) { // 单向链表
    //     let hook;
    //     // 判断是否首次渲染
    //     if (isMount) {
    //         hook = {
    //             memoizeState: initState,
    //             next: null,
    //             queue: {
    //                 padding: null
    //             }
    //         }
    //         //
    //         if(!fiber.memoizeState) {
    //             fiber.memoizeState = hook
    //         } else {
    //             // 多个useState
    //             workInprogressHook.next = hook
    //         }
    //         workInprogressHook = hook
    //     } else { // update阶段
    //         hook = workInprogressHook
    //         workInprogressHook = workInprogressHook.next

    //     }
    //     let baseState = hook.memoizeState
        
    //     // if(typeof state === 'funcion') {

    //     // }
    // }
    // function dispatchAction(queue, action) { // 环状链表
    //     const update = {
    //         action,
    //         next: null
    //     }
    //     if(queue.padding === null) {
    //         update.next = update
    //     } else{ // u1 => u0 => u1
    //         update.next = queue.padding.next
    //         queue.padding.next = update
    //     }
    //     queue.padding = update
    //     schedule()
    // }
    // function App () {
    //     const [num, setNum] = useState(0)
    //     return{
    //         onClick() {
    //             useState(num+1)
    //         }
    //     }
    // }
    // this.app = schedule()











</script>
</html> 